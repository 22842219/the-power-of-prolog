; (solve)
; (A->B B->C C->A B->C A->B B->C C->A)

(defun successors (state)
  (let* ((path (first state))
	 (jugs (second state))
	 (a (first jugs))
	 (b (second jugs))
	 (c (third jugs))
	 (ab (min a (- 5 b)))
	 (ac (min a (- 3 c)))
	 (ba (min b (- 8 a)))
	 (bc (min b (- 3 c)))
	 (ca (min c (- 8 a)))
	 (cb (min c (- 5 b)))
	 (sab `((a->b ,@path) (,(- a ab) ,(+ b ab) ,c)))
	 (sac `((a->c ,@path) (,(- a ac) ,b ,(+ c ac))))
	 (sba `((b->a ,@path) (,(+ a ba) ,(- b ba) ,c)))
	 (sbc `((b->c ,@path) (,a ,(- b bc) ,(+ c bc))))
	 (sca `((c->a ,@path) (,(+ a ca) ,b ,(- c ca))))
	 (scb `((c->b ,@path) (,a ,(+ b cb) ,(- c cb)))))
    (append (if (> ab 0) `(,sab) nil) (if (> ac 0) `(,sac) nil)
	    (if (> ba 0) `(,sba) nil) (if (> bc 0) `(,sbc) nil)
	    (if (> ca 0) `(,sca) nil) (if (> cb 0) `(,scb) nil))))


(defun find-path (states)
  (let* ((state (car states))
	 (moves (first state))
	 (jugs (second state)))
    (if (equal jugs '(4 4 0))
	(reverse moves)
      (find-path (append (cdr states) (successors state))))))


(defun solve ()
  (let* ((start-state '(nil (8 0 0)))
	 (moves (find-path (list start-state))))
    moves))

